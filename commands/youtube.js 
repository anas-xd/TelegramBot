/**
 *  YOUTUBE PRO MODULE
 *  Clean ‚Ä¢ Stable ‚Ä¢ Fast ‚Ä¢ Inline Search ‚Ä¢ Auto Fallback ‚Ä¢ MP4/MP3
 */

const axios = require("axios");
const fs = require("fs");
const crypto = require("crypto");

/* ---------------------- BASIC HELPERS ---------------------- */

const getAPI = async () => {
  const res = await axios.get(
    "https://raw.githubusercontent.com/Blankid018/D1PT0/main/baseApiUrl.json"
  );
  return res.data.api;
};

const token = () => crypto.randomBytes(6).toString("hex");

const ytRegex =
  /^(?:https?:\/\/)?(?:m\.|www\.)?(?:youtube\.com\/|youtu\.be\/)/i;

/* -------------------- DOWNLOAD FUNCTION -------------------- */

async function downloadAndSend(ctx, videoID, format = "mp4") {
  const api = await getAPI();
  const qualities = [0, 3, 2, 1];

  for (const q of qualities) {
    try {
      const { data } = await axios.get(
        `${api}/ytDl3?link=${videoID}&format=${format}&quality=${q}`
      );

      if (!data?.downloadLink) continue;

      const prog = await ctx.reply(
        `‚è≥ Downloading *${data.title}*...`,
        { parse_mode: "Markdown" }
      );

      const bin = await axios.get(data.downloadLink, {
        responseType: "arraybuffer",
        timeout: 120000,
      });

      const file = `tmp_${videoID}.${format}`;
      fs.writeFileSync(file, Buffer.from(bin.data));

      try {
        if (format === "mp4") {
          await ctx.replyWithVideo({ source: file }, { caption: data.title });
        } else {
          await ctx.replyWithAudio({ source: file }, { caption: data.title });
        }

        await ctx.deleteMessage(prog.message_id).catch(() => {});
        fs.unlinkSync(file);
        return true;
      } catch {
        fs.unlinkSync(file);
        await ctx.deleteMessage(prog.message_id).catch(() => {});
        return ctx.reply(`‚ö†Ô∏è Too large to send. Link:\n${data.downloadLink}`);
      }
    } catch {}
  }

  return ctx.reply("‚ùå Could not download.");
}

/* -------------------------- EXPORT -------------------------- */

module.exports = {
  name: "youtube",
  aliases: ["yt", "ytdl"],
  adminOnly: false,

  /* ------------------------- MAIN RUN ------------------------- */

  run: async (ctx) => {
    const args = ctx.args || [];
    if (!args.length)
      return ctx.reply("‚ùå Usage: /yt <link|search> [-v|-a|-i]");

    const flags = args.filter((a) => a.startsWith("-"));
    const action =
      flags[0] ||
      (["video", "-v"].includes(args[0]) && "video") ||
      (["audio", "-a"].includes(args[0]) && "audio") ||
      (["info", "-i"].includes(args[0]) && "info") ||
      "auto";

    const clean = args.filter((a) => !a.startsWith("-"));
    const query = clean.join(" ");
    const first = clean[0];

    /* ------------------- DIRECT LINK MODE ------------------- */

    if (ytRegex.test(first)) {
      const match = first.match(
        /(?:v=|youtu\.be\/|shorts\/)([\w-]{11})/
      );
      const ID = match?.[1];

      if (!ID) return ctx.reply("‚ùå Invalid YouTube link.");

      if (action === "-i" || action === "info") {
        const api = await getAPI();
        const { data } = await axios.get(`${api}/ytfullinfo?videoID=${ID}`);

        const caption = `üé¨ *${data.title}*
‚è± ${(data.duration / 60).toFixed(2)} min
üì∫ ${data.resolution}
üëÄ ${data.view_count}`;

        return ctx.replyWithPhoto(
          { url: data.thumbnail },
          { caption, parse_mode: "Markdown" }
        );
      }

      return downloadAndSend(ctx, ID, action === "audio" ? "mp3" : "mp4");
    }

    /* ---------------------- SEARCH MODE ---------------------- */

    const api = await getAPI();
    const results = (
      await axios.get(`${api}/ytFullSearch?songName=${encodeURIComponent(query)}`)
    ).data;

    if (!results?.length)
      return ctx.reply(`‚≠ï No results for: *${query}*`, {
        parse_mode: "Markdown",
      });

    const listToken = token();

    global.inlineHandlers = global.inlineHandlers || {};
    global.inlineHandlers[listToken] = {
      user: ctx.from.id,
      results,
      action,
    };

    let text = `üîé *Results for:* _${query}_\n\n`;
    results.slice(0, 6).forEach((v, i) => {
      text += `${i + 1}. *${v.title}*\n   ‚è± ${v.time} ‚Ä¢ ${v.channel.name}\n\n`;
    });

    const keyboard = results.slice(0, 6).map((v, i) => [
      {
        text: `${i + 1}`,
        callback_data: `youtube|${listToken}|${i + 1}`,
      },
    ]);

    keyboard.push([
      { text: "üéß Audio", callback_data: `youtube|${listToken}|fmt|mp3` },
      { text: "üé• Video", callback_data: `youtube|${listToken}|fmt|mp4` },
      { text: "‚úñ Cancel", callback_data: `youtube|${listToken}|cancel` },
    ]);

    return ctx.reply(text, {
      parse_mode: "Markdown",
      reply_markup: { inline_keyboard: keyboard },
    });
  },

  /* -------------------- INLINE RESULT HANDLER -------------------- */

  handleCallback: async (ctx, key, type, val) => {
    const cache = global.inlineHandlers?.[key];
    if (!cache) return ctx.answerCbQuery("Expired.");

    if (ctx.from.id !== cache.user)
      return ctx.answerCbQuery("Not for you.", { show_alert: true });

    if (type === "cancel") {
      delete global.inlineHandlers[key];
      await ctx.editMessageReplyMarkup({ inline_keyboard: [] }).catch(() => {});
      return ctx.answerCbQuery("Cancelled.");
    }

    // format switch
    if (type === "fmt") {
      cache.forceFormat = val;
      return ctx.answerCbQuery(`Format = ${val}`);
    }

    // index selection
    const idx = Number(type) - 1;
    const item = cache.results[idx];
    if (!item) return ctx.answerCbQuery("Invalid.");

    await ctx.editMessageReplyMarkup({ inline_keyboard: [] }).catch(() => {});
    await ctx.answerCbQuery("Processing...");

    const format =
      cache.forceFormat ||
      (cache.action === "audio" ? "mp3" : "mp4");

    return downloadAndSend(ctx, item.id, format);
  },
};